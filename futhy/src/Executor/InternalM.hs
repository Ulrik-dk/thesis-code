module Executor.InternalM where

import Types
import System.IO (openTempFile, hClose)
import System.Process (readProcessWithExitCode, showCommandForUser)
import System.FilePath (dropExtension)
import Control.Monad.Reader
import Control.Monad.Except (throwError)
import GHC.IO.Exception (ExitCode(..))

p :: String -> Command ()
p = liftIO . print

-- |Compile the Futhark source code in env.
compile :: Command ExecutionResult
compile = do
  Env filepath backend <- ask
  let futExec = "futhark"
  let futParams = [show backend, filepath]
  p $ "[Futhark] Command going to be run: " ++ showCommandForUser futExec futParams

  (exitcode, stdout, stdin) <- liftIO $ readProcessWithExitCode futExec futParams ""
  case exitcode of
      ExitFailure _ -> throwError (CompilationError exitcode)
      ExitSuccess   -> return (exitcode, stdout, stdin) 

  p   "[Futhark] Compilation results:"
  p $ "[Futhark] ExitCode: " ++ show exitcode
  p $ "[Futhark] stdout:   " ++ show stdout
  p $ "[Futhark] stdin :   " ++ show stdin
  p   "[Futhark] Compilation COMPLETED"
  return (exitcode, stdout, stdin)

-- |Execute the compiled Futhark executable 'futExec' containing the compiled linear program.
execute :: Command ExecutionResult
execute = do
  filepath <- asks fp
  let executable = dropExtension filepath
  let params = []
  p $ "[LinPgm] Command going to be run: " ++ showCommandForUser executable params
  (exitcode, stdout, stdin) <- liftIO $ readProcessWithExitCode executable params "\n"
  p   "[LinPgm] Execution results:"
  p $ "[LinPgm] ExitCode: " ++ show exitcode
  p $ "[LinPgm] stdout:   " ++ show stdout
  p $ "[LinPgm] stdin :   " ++ show stdin
  p   "[LinPgm] Execution ENDED"
  return (exitcode, stdout, stdin)

runFileM :: Command ExecutionResult
runFileM = compile >> execute

makeTemp :: Command FutPgmFile
makeTemp = do
  let path   = "build/"
  let prefix = "autogenerated_.fut"
  (filepath, handle) <- liftIO $ openTempFile path prefix
  liftIO $ hClose handle
  p filepath
  return filepath

writeTemp :: FutPgmStr -> Command ()
writeTemp futStr = do
  filepath <- asks fp
  liftIO $ writeFile filepath futStr

store :: FutPgmStr -> Command FutPgmFile
store futPgmStr = do
  filepath <- makeTemp
  backend <- asks be
  let envNew = Env { fp = filepath, be = backend }
  local (const envNew) (writeTemp futPgmStr)
  return filepath

runStrM :: FutPgmStr -> Command ExecutionResult
runStrM futPgmStr = do
  filepath <- store futPgmStr
  backend <- asks be
  let envNew = Env { fp = filepath, be = backend }
  local (const envNew) runFileM

runStr :: FutPgmStr -> Backend -> IO (Either ExecutionError ExecutionResult)
runStr futPgmStr backend =
  let envInit = Env { fp = "", be = backend }
  in execCmd (runStrM futPgmStr) envInit

runFile :: FutPgmFile -> Backend -> IO (Either ExecutionError ExecutionResult)
runFile futPgmFile backend =
  let envInit = Env { fp = futPgmFile, be = backend }
  in execCmd runFileM envInit
