module Executor.InternalM where

import Types
import System.IO (openTempFile, hClose)
import System.Process (readProcessWithExitCode, showCommandForUser)
import System.FilePath (dropExtension)
import Control.Monad.Reader
import Control.Monad.Except (throwError)
import GHC.IO.Exception (ExitCode(..))

p :: String -> Command ()
p = liftIO . print

-- |Compile the Futhark source code in env.
compile :: Command ExecutionResult
compile = do
  Env filepath backend <- ask
  let futExec = "futhark"
  let futParams = [show backend, filepath]
  p $ "[Futhark] Command going to be run: " ++ showCommandForUser futExec futParams

  (exitcode, stdout, stdin) <- liftIO $ readProcessWithExitCode futExec futParams ""
  case exitcode of
         ExitFailure _ -> throwError (CompilationError (exitcode, stdout, stdin))
         ExitSuccess   -> return ()

  p   "[Futhark] Compilation results:"
  p $ "[Futhark] ExitCode: " ++ show exitcode
  p $ "[Futhark] stdout:   " ++ show stdout
  p $ "[Futhark] stdin :   " ++ show stdin
  p   "[Futhark] Compilation COMPLETED"
  return (exitcode, stdout, stdin)

-- |Execute the compiled Futhark executable 'futExec' containing the compiled linear program.
executeArg :: String -> Command ExecutionResult
executeArg arg = do
  filepath <- asks fp
  let executable = dropExtension filepath
  let params = []
  p $ "[LinPgm] Command going to be run: " ++ showCommandForUser executable params

  (exitcode, stdout, stdin) <- liftIO $ readProcessWithExitCode executable params arg
  case exitcode of
         ExitFailure _ -> throwError (ExecutionError exitcode)
         ExitSuccess   -> return ()

  p   "[LinPgm] Execution results:"
  p $ "[LinPgm] ExitCode: " ++ show exitcode
  p $ "[LinPgm] stdout:   " ++ show stdout
  p $ "[LinPgm] stdin :   " ++ show stdin
  p   "[LinPgm] Execution ENDED"
  return (exitcode, stdout, stdin)

runFileArgM :: String -> Command ExecutionResult
runFileArgM arg = compile >> executeArg arg

makeTemp :: Command FutPgmFile
makeTemp = do
  let path   = "build/"
  let prefix = "autogenerated_.fut"
  (filepath, handle) <- liftIO $ openTempFile path prefix
  liftIO $ hClose handle
  p filepath
  return filepath

writeTemp :: FutPgmStr -> Command ()
writeTemp futStr = do
  filepath <- asks fp
  liftIO $ writeFile filepath futStr

store :: FutPgmStr -> Command FutPgmFile
store futPgmStr = do
  filepath <- makeTemp
  backend <- asks be
  let envNew = Env { fp = filepath, be = backend }
  local (const envNew) (writeTemp futPgmStr)
  return filepath

runStrArgM :: String -> FutPgmStr -> Command ExecutionResult
runStrArgM arg futPgmStr = do
  filepath <- store futPgmStr
  backend <- asks be
  let envNew = Env { fp = filepath, be = backend }
  local (const envNew) (runFileArgM arg)


--- entrypoints
runStrArg :: String -> FutPgmStr -> Backend -> IO (Either ExecutionError ExecutionResult)
runStrArg arg futPgmStr backend =
  let envInit = Env { fp = "", be = backend }
  in execCmd (runStrArgM futPgmStr arg) envInit

runFileArg :: String -> FutPgmFile -> Backend -> IO (Either ExecutionError ExecutionResult)
runFileArg arg futPgmFile backend =
  let envInit = Env { fp = futPgmFile, be = backend }
  in execCmd (runFileArgM arg) envInit

runStr :: FutPgmStr -> Backend -> IO (Either ExecutionError ExecutionResult)
runStr = (runStrArg "\n")

runFile :: FutPgmFile -> Backend -> IO (Either ExecutionError ExecutionResult)
runFile = (runFileArg "\n")
