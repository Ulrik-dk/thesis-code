

-- {-# LANGUAGE QuasiQuotes #-}

module Executer
  ( runFile
  , runStr
  , runStrArg
  , benchmark
  ) where

import Types
import System.IO (openTempFile, hClose, stderr, hPutStrLn)
import System.Process (readProcessWithExitCode, showCommandForUser)
import System.FilePath (dropExtension)
import Control.Monad.Reader
import Control.Monad.Except (throwError)
import Flow
import CodeGen (completeCodeGen)

p :: String -> Command ()
p s =
  let debug = True
  in when debug (liftIO <| hPutStrLn stderr s)

makeLog :: CommandOutput -> Json -> Log
makeLog (_exitcode, _stdout, _stdin) json = Log
  { exitcode = _exitcode
  , stdout   = show _stdout
  , stdin    = show _stdin
  , json     = json
  }

-- |Compile the Futhark source code in env.
compile :: Command Result
compile = do
  Env filepath backend _ <- ask
  let futExec = "futhark"
  let futParams = [show backend, filepath]
  p $ "[Futhark] Command going to be run: " ++ showCommandForUser futExec futParams

  output@(_exitcode, _stdout, _stdin) <- liftIO <| readProcessWithExitCode futExec futParams ""
  when (isExitFailure _exitcode)    <| throwError (CommandFailure CompilationError output)

  p   "[Futhark] Compilation results:"
  p $ "[Futhark] ExitCode: " ++ show _exitcode
  p $ "[Futhark] stdout:   " ++ show _stdout
  p $ "[Futhark] stdin :   " ++ show _stdin
  p   "[Futhark] Compilation COMPLETED"
  let compileLog = makeLog output ""
  return (Result compileLog)

-- |Execute the compiled Futhark executable 'futExec' containing the compiled linear program.
makeTemp :: Command FutPgmFile
makeTemp = do
  let path   = "build/"
  let prefix = "autogenerated_.fut"
  (filepath, handle) <- liftIO $ openTempFile path prefix
  liftIO $ hClose handle
  -- p filepath
  return filepath

writeToFile :: FutPgmStr -> Command ()
writeToFile futStr = do
  filepath <- asks fp
  liftIO   <| writeFile filepath futStr

store :: FutPgmStr -> Command FutPgmFile
store futPgmStr = do
  filepath <- makeTemp
  backend  <- asks be
  let envNew = Env { fp = filepath, be = backend, runs = 0 }
  local (const envNew) (writeToFile futPgmStr)
  return filepath

runStr :: FutPgmStr -> Backend -> IO (CommandExecution Result)
runStr futPgmStr backend = runStrArg futPgmStr backend "\n"

runFile :: FutPgmFile -> Backend -> IO (CommandExecution Result)
runFile futPgmFile backend =
  let envInit = Env { fp = futPgmFile, be = backend, runs = 0 }
  in execCmd (runFileArgM "\n") envInit

--- but with std'ins
executeArg :: StdInArg -> Command Result
executeArg val = do
  filepath <- asks fp
  let executable = dropExtension filepath
  let params = []
  p $ "[LinPgm] Command going to be run: " ++ showCommandForUser executable params ++ " " ++ val

  output@(_exitcode, _stdout, _stdin) <- liftIO $ readProcessWithExitCode executable params val
  when (isExitFailure _exitcode)    <| throwError (CommandFailure ExecutionError output)

  p   "[LinPgm] Execution results:"
  p $ "[LinPgm] ExitCode: " ++ show _exitcode
  p $ "[LinPgm] stdout:   " ++ show _stdout
  p $ "[LinPgm] stdin :   " ++ show _stdin
  p   "[LinPgm] Execution ENDED"
  let executeLog = makeLog output ""
  return (Result executeLog)

runFileArgM :: StdInArg -> Command Result
runFileArgM val = compile >> executeArg val

runStrArgM :: FutPgmStr -> StdInArg -> Command Result
runStrArgM futPgmStr val = do
  filepath <- store futPgmStr
  backend  <- asks be
  let envNew = Env { fp = filepath, be = backend, runs = 0 }
  local (const envNew) (runFileArgM val)

runStrArg :: FutPgmStr -> Backend -> StdInArg -> IO (CommandExecution Result)
runStrArg futPgmStr backend val =
  let envInit = Env { fp = "", be = backend, runs = 0 }
  in execCmd (runStrArgM futPgmStr val) envInit

{-
-- BENCHMARKS

-- How quickly can we reduce arrays?
--
-- ==
-- nobench input { 0i64 }
-- output { 0i64 }
-- input { 100i64 }
-- output { 4950i64 }
-- compiled input { 10000i64 }
-- output { 49995000i64 }
-- compiled input { 1000000i64 }
-- output { 499999500000i64 }

let main(n: i64): i64 =
  reduce (+) 0 (iota n)


printHeader :: Val -> IO ()
printHeader = putStrLn . makeHeader
-}

makeHeader :: Val -> FutPgmStr
makeHeader val = concat
  [ "-- Autogenerated benchmark.  Edits will be overwritten.\n"
  , "--\n"
  , "-- ==\n"
  , "-- input { " ++ show val ++ " }\n\n"
  ]

benchmark :: FilePath -> LFun -> Val -> Backend -> Runs -> IO (CommandExecution Result)
benchmark filename futPgmStr val backend _runs =
  let path = "build/"
      fullname = path ++ filename ++ ".fut"
      futPgmCompiled = completeCodeGen futPgmStr val
   in execCmd (benchmarkM futPgmCompiled val)
      <| Env { fp=fullname, be=backend, runs=_runs }

benchmarkM :: FutPgmStr -> Val -> Command Result
benchmarkM futPgmStr val = do
  writeToFile <| makeHeader val ++ futPgmStr
  runBenchmark

runBenchmark :: Command Result
runBenchmark = do
  Env filepath _ _runs <- ask
  let executable = "futhark"
  let jsonfile = dropExtension filepath ++ ".json"
  -- Documentation: https://futhark.readthedocs.io/en/stable/man/futhark-bench.html#futhark-bench-1
  let { params =
        [ "bench"
        , "--json=" ++ jsonfile
        , "--runs=" ++ show _runs
        , filepath
        ]
      }
  p $ "[Benchmark] Command to be run: " ++ showCommandForUser executable params

  output@(_exitcode, _stdout, _stdin) <- liftIO <| readProcessWithExitCode executable params ""
  when (isExitFailure _exitcode)              <| throwError (CommandFailure ExecutionError output)

  json <- liftIO <| readFile jsonfile

  p   "[Benchmark] Execution results:"
  p $ "[Benchmark] ExitCode: " ++ show _exitcode
  p $ "[Benchmark] stdout:   " ++ _stdout
  p $ "[Benchmark] stdin :   " ++ _stdin
  p   "[Benchmark] Execution ENDED"
  p $ "[Benchmark] View results with: 'jq . " ++ jsonfile ++ "'"
  let benchmarkLog = makeLog output json
  return (Result benchmarkLog)
